# NOTE: This class is auto generated by the swagger code generator program.
# https://github.com/swagger-api/swagger-codegen.git
# Do not edit the class manually.

defmodule Voxbone.Api.RegulationAPI do
  @moduledoc """
  API calls for all endpoints tagged `RegulationAPI`.
  """

  alias Voxbone.Connection
  import Voxbone.RequestBuilder

  @doc """
  Allows you to separately upload a proof of ID after the address is created (the upload is done automatically during the address creation if the document is specified).


  ## Parameters

  - connection (Voxbone.Connection): Connection to server
  - body2 (Attachment): The proof of identity document.
  - opts (KeywordList): [optional] Optional parameters
    - :body (CreateProofOfIdRequest): 

  ## Returns

  {:ok, %Voxbone.Model.CreateProofOfIdResponse{}} on success
  {:error, info} on failure
  """
  @spec create_proof_of_identity_document(
          Tesla.Env.client(),
          Voxbone.Model.Attachment.t(),
          keyword()
        ) :: {:ok, Voxbone.Model.CreateProofOfIdResponse.t()} | {:error, Tesla.Env.t()}
  def create_proof_of_identity_document(connection, body2, opts \\ []) do
    optional_params = %{
      :body => :body
    }

    %{}
    |> method(:put)
    |> url("/regulation/identitydocument")
    |> add_param(:body, :body, body2)
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> decode(%Voxbone.Model.CreateProofOfIdResponse{})
  end

  @doc """
  Allows you to create a new end user&#39;s address that can be linked to DIDs where a local address requirement (LAR) applies. The method allows the attachment of a proof of address.
  Note: If a proof of address is attached, the system automatically triggers a &#39;request for verification&#39; so that Voxbone can manually verify the address elements. The media type to be used is multipart/form-data.

  ## Parameters

  - connection (Voxbone.Connection): Connection to server
  - opts (KeywordList): [optional] Optional parameters
    - :create_regulation_address_request (CreateRegulationAddressRequest): Request parameters
    - :proof_of_identity_document (Attachment): Proof of identity document
    - :body ([Attachment]): This is an element represented by an attachment to the request sent for the creation and upload of a proof of address. The content ID can be any name different than createRegulationAddressRequest and proofOfIdentityDocument. For REST requests, multipart/form-data should be used as a media type.

  ## Returns

  {:ok, %Voxbone.Model.CreateRegulationAddressResponse{}} on success
  {:error, info} on failure
  """
  @spec create_regulation_address(Tesla.Env.client(), keyword()) ::
          {:ok, Voxbone.Model.CreateRegulationAddressResponse.t()} | {:error, Tesla.Env.t()}
  def create_regulation_address(connection, opts \\ []) do
    optional_params = %{
      :createRegulationAddressRequest => :body,
      :proofOfIdentityDocument => :body,
      :body => :body
    }

    %{}
    |> method(:put)
    |> url("/regulation/address")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> decode(%Voxbone.Model.CreateRegulationAddressResponse{})
  end

  @doc """
  Allows you to delete a regulation address.


  ## Parameters

  - connection (Voxbone.Connection): Connection to server
  - regulation_address_id (integer()): The ID of the regulation address that you want to delete. You can only delete one address per request.
  - opts (KeywordList): [optional] Optional parameters

  ## Returns

  {:ok, %Voxbone.Model.DeleteRegulationAddressResponse{}} on success
  {:error, info} on failure
  """
  @spec delete_regulation_address(Tesla.Env.client(), integer(), keyword()) ::
          {:ok, Voxbone.Model.DeleteRegulationAddressResponse.t()} | {:error, Tesla.Env.t()}
  def delete_regulation_address(connection, regulation_address_id, _opts \\ []) do
    %{}
    |> method(:delete)
    |> url("/regulation/address/#{regulation_address_id}")
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> decode(%Voxbone.Model.DeleteRegulationAddressResponse{})
  end

  @doc """
  Allows you to retrieve details of a regulation address.


  ## Parameters

  - connection (Voxbone.Connection): Connection to server
  - regulation_address_id (integer()): The ID of the regulation address.
  - opts (KeywordList): [optional] Optional parameters

  ## Returns

  {:ok, %Voxbone.Model.ListRegulationAddressResponse{}} on success
  {:error, info} on failure
  """
  @spec get_regulation_address(Tesla.Env.client(), integer(), keyword()) ::
          {:ok, Voxbone.Model.ListRegulationAddressResponse.t()} | {:error, Tesla.Env.t()}
  def get_regulation_address(connection, regulation_address_id, _opts \\ []) do
    %{}
    |> method(:get)
    |> url("/regulation/address/#{regulation_address_id}")
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> decode(%Voxbone.Model.ListRegulationAddressResponse{})
  end

  @doc """
  Allows to check the validity of an address against a certain DID&#39;s type and country. This can be useful if you have originally created an address for a given DID and you wish to reuse that same address for another DID.


  ## Parameters

  - connection (Voxbone.Connection): Connection to server
  - regulation_address_id (integer()): The ID of the regulation address.
  - did_type (String.t): The did type for the destination did.
  - destination_country_code_a3 (String.t): The three letter identifier for country of the destination did.
  - opts (KeywordList): [optional] Optional parameters

  ## Returns

  {:ok, %Voxbone.Model.IsAddressValidResponse{}} on success
  {:error, info} on failure
  """
  @spec is_address_valid(Tesla.Env.client(), integer(), String.t(), String.t(), keyword()) ::
          {:ok, Voxbone.Model.IsAddressValidResponse.t()} | {:error, Tesla.Env.t()}
  def is_address_valid(
        connection,
        regulation_address_id,
        did_type,
        destination_country_code_a3,
        _opts \\ []
      ) do
    %{}
    |> method(:get)
    |> url("/regulation/address/#{regulation_address_id}/validation")
    |> add_param(:query, :didType, did_type)
    |> add_param(:query, :destinationCountryCodeA3, destination_country_code_a3)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> decode(%Voxbone.Model.IsAddressValidResponse{})
  end

  @doc """
  Allows you to link one or multiple DIDs to a regulation address.


  ## Parameters

  - connection (Voxbone.Connection): Connection to server
  - regulation_address_id (integer()): The ID of the regulation address.
  - body (LinkRegulationAddressRequest): 
  - opts (KeywordList): [optional] Optional parameters

  ## Returns

  {:ok, %Voxbone.Model.LinkRegulationAddressResponse{}} on success
  {:error, info} on failure
  """
  @spec link_regulation_address(
          Tesla.Env.client(),
          integer(),
          Voxbone.Model.LinkRegulationAddressRequest.t(),
          keyword()
        ) :: {:ok, Voxbone.Model.LinkRegulationAddressResponse.t()} | {:error, Tesla.Env.t()}
  def link_regulation_address(connection, regulation_address_id, body, _opts \\ []) do
    %{}
    |> method(:post)
    |> url("/regulation/address/#{regulation_address_id}/link")
    |> add_param(:body, :body, body)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> decode(%Voxbone.Model.LinkRegulationAddressResponse{})
  end

  @doc """
  Allows you to list all your existing regulation addresses.


  ## Parameters

  - connection (Voxbone.Connection): Connection to server
  - page_number (integer()): The page number, starting at 0.
  - page_size (integer()): The page size (max number of entities that are displayed in the response).
  - opts (KeywordList): [optional] Optional parameters
    - :regulation_address_id (integer()): This is the ID of the regulation address which is returned by createRegulationAddress.
    - :company_name (String.t): Name of the company.
    - :first_name (String.t): First name of the customer.
    - :last_name (String.t): Last name of the customer.
    - :country_code_a3 (String.t): The three letter identifier for the address&#39;s country.
    - :city (String.t): The city for the address.
    - :zip_code (String.t): The zip code for the address.
    - :street_name (String.t): The street for the address.
    - :building_number (String.t): The building number for the address.
    - :customer_reference (String.t): The reference for the customer.
    - :status (String.t): The status of the regulation address.
    - :linked (boolean()): Flag that specifies if the address has been linked to a DID.

  ## Returns

  {:ok, %Voxbone.Model.ListRegulationAddressResponse{}} on success
  {:error, info} on failure
  """
  @spec list_regulation_address(Tesla.Env.client(), integer(), integer(), keyword()) ::
          {:ok, Voxbone.Model.ListRegulationAddressResponse.t()} | {:error, Tesla.Env.t()}
  def list_regulation_address(connection, page_number, page_size, opts \\ []) do
    optional_params = %{
      :regulationAddressId => :query,
      :companyName => :query,
      :firstName => :query,
      :lastName => :query,
      :countryCodeA3 => :query,
      :city => :query,
      :zipCode => :query,
      :streetName => :query,
      :buildingNumber => :query,
      :customerReference => :query,
      :status => :query,
      :linked => :query
    }

    %{}
    |> method(:get)
    |> url("/regulation/address")
    |> add_param(:query, :pageNumber, page_number)
    |> add_param(:query, :pageSize, page_size)
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> decode(%Voxbone.Model.ListRegulationAddressResponse{})
  end

  @doc """
  Allows you to get the matching cities and zip codes for a certain country or DID&#39;s area code. This is an absolute requirement for certain countries where the city and zip code will have to match the DID&#39;s area code for instance in Germany (DEU), Croatia (HRV), South Korea (KOR), etcâ€¦
  For some DID Groups with an address&#x3D;LOCAL requirement, the ListZipcodes returns no items. This indicates that the regulation is not strict about the Zipcode matching the local address and hence any valid zip code can be entered (it will not be checked).

  ## Parameters

  - connection (Voxbone.Connection): Connection to server
  - country_code_a3 (String.t): This is the country code A3 of the country for which the list of zip codes and cities is needed. In practice, the area code will also be needed to identify specifically which cities and zip codes are a match.
  - page_number (integer()): The page number, starting at 0.
  - page_size (integer()): The page size (max number of entities that are displayed in the response).
  - opts (KeywordList): [optional] Optional parameters
    - :area_code (String.t): This is the area code of the DID which can be retrieved using the listDidGroup or listDid methods. Since an area code can be the same for two different countries, the country should also be specified. If the whole list for a given country is needed, then you can leave the area code unspecified.

  ## Returns

  {:ok, %Voxbone.Model.ListZipCodesResponse{}} on success
  {:error, info} on failure
  """
  @spec list_zip_codes(Tesla.Env.client(), String.t(), integer(), integer(), keyword()) ::
          {:ok, Voxbone.Model.ListZipCodesResponse.t()} | {:error, Tesla.Env.t()}
  def list_zip_codes(connection, country_code_a3, page_number, page_size, opts \\ []) do
    optional_params = %{
      :areaCode => :query
    }

    %{}
    |> method(:get)
    |> url("/regulation/zipcode")
    |> add_param(:query, :countryCodeA3, country_code_a3)
    |> add_param(:query, :pageNumber, page_number)
    |> add_param(:query, :pageSize, page_size)
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> decode(%Voxbone.Model.ListZipCodesResponse{})
  end

  @doc """
  Allows you to request a separate address verification.
  Note: This can happen if you want to use an existing address which didn&#39;t require verification for the DIDs it is linked to, or for which the proof of address was rejected. You need to upload a proof of address and then request address verification if you wish to link the address to DIDs requiring a proof of address. Calling this method for addresses that are in VERIFICATION_NOT_REQUIRED status will return an error.

  ## Parameters

  - connection (Voxbone.Connection): Connection to server
  - regulation_address_id (integer()): The identifier of the regulation address.
  - opts (KeywordList): [optional] Optional parameters

  ## Returns

  {:ok, %Voxbone.Model.RequestAddressVerificationResponse{}} on success
  {:error, info} on failure
  """
  @spec request_address_verification(Tesla.Env.client(), integer(), keyword()) ::
          {:ok, Voxbone.Model.RequestAddressVerificationResponse.t()} | {:error, Tesla.Env.t()}
  def request_address_verification(connection, regulation_address_id, _opts \\ []) do
    %{}
    |> method(:put)
    |> url("/regulation/address/#{regulation_address_id}/verification")
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> decode(%Voxbone.Model.RequestAddressVerificationResponse{})
  end

  @doc """
  Allows you to unlink DIDs from an address.


  ## Parameters

  - connection (Voxbone.Connection): Connection to server
  - opts (KeywordList): [optional] Optional parameters
    - :body (LinkRegulationAddressRequest): 

  ## Returns

  {:ok, %Voxbone.Model.LinkRegulationAddressResponse{}} on success
  {:error, info} on failure
  """
  @spec unlink_regulation_address(Tesla.Env.client(), keyword()) ::
          {:ok, Voxbone.Model.LinkRegulationAddressResponse.t()} | {:error, Tesla.Env.t()}
  def unlink_regulation_address(connection, opts \\ []) do
    optional_params = %{
      :body => :body
    }

    %{}
    |> method(:post)
    |> url("/regulation/address/unlink")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> decode(%Voxbone.Model.LinkRegulationAddressResponse{})
  end

  @doc """
  Allows you to separately upload a proof of address after the address is created (the upload is done automatically during the address creation if the document is specified).
  This can happen if you want to use an existing address which didn&#39;t require verification for the DIDs it is linked to, or for which the proof of address was rejected. After an uploadProofOfAddress request the requestAddressVerification method must be called.

  ## Parameters

  - connection (Voxbone.Connection): Connection to server
  - regulation_address_id (integer()): The identifier of the regulation address.
  - opts (KeywordList): [optional] Optional parameters
    - :body ([Attachment]): List of documents - the first one will be set as proof of address.

  ## Returns

  {:ok, %Voxbone.Model.UploadProofOfAddressResponse{}} on success
  {:error, info} on failure
  """
  @spec upload_proof_of_address(Tesla.Env.client(), integer(), keyword()) ::
          {:ok, Voxbone.Model.UploadProofOfAddressResponse.t()} | {:error, Tesla.Env.t()}
  def upload_proof_of_address(connection, regulation_address_id, opts \\ []) do
    optional_params = %{
      :body => :body
    }

    %{}
    |> method(:put)
    |> url("/regulation/address/#{regulation_address_id}/proof")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> decode(%Voxbone.Model.UploadProofOfAddressResponse{})
  end
end
